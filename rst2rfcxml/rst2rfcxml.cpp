// Copyright (c) Dave Thaler
// SPDX-License-Identifier: MIT

#include <fstream>
#include <sstream>
#include <string>
#include "..\external\CLI11.HPP"
#include "rst2rfcxml.h"

using namespace std;

// Output XML header.
void rst2rfcxml::output_header(ostream& output_stream) const
{
	output_stream << R"(<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
  <!-- generated by https://github.com/dthaler/rst2rfcxml version 0.1 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

)";

	output_stream << std::format("<rfc ipr=\"{}\" docName=\"{}\" category=\"{}\">", _ipr, _document_name, _category) << endl << endl;
	output_stream << "  <front>" << endl;
	output_stream << "  </front>" << endl << endl;
	output_stream << "  <middle>" << endl;
}

// Output XML footer.
void rst2rfcxml::output_footer(ostream& output_stream) const
{
	output_stream << "  </middle>" << endl;
	output_stream << "  <back>" << endl;
	output_stream << "  </back>" << endl;
	output_stream << "</rfc>" << endl;
}

// Replace occurrences of ``foo`` with <tt>foo</tt>.
string rst2rfcxml::replace_constant_width_instances(string line) const
{
	size_t index;
	while ((index = line.find("``")) != string::npos) {
		size_t next_index = line.find("``", index + 2);
		if (next_index == string::npos) {
			break;
		}
		string before = line.substr(0, index);
		string middle = line.substr(index + 2, next_index - index - 2);
		string after = line.substr(next_index + 2);
		line = format("{}<tt>{}</tt>{}", before, middle, after);
	}
	return line;
}

void rst2rfcxml::process_line(string line, ostream& output_stream)
{
	line = replace_constant_width_instances(line);

	if (line == ".. contents::") {
		// Include table of contents.
		// This is already the default in rfc2xml.
		return;
	}
	if (line == ".. sectnum::") {
		// Number sections.
		// This is already the default in rfc2xml.
		return;
	}

	// Handle setting some field replacement values.
	string ipr_prefix = ".. |ipr| replace:: ";
	if (line.starts_with(ipr_prefix)) {
		_ipr = line.substr(ipr_prefix.length());
		return;
	}
	string category_prefix = ".. |category| replace:: ";
	if (line.starts_with(category_prefix)) {
		_category = line.substr(category_prefix.length());
		return;
	}
	string docname_prefix = ".. |docName| replace:: ";
	if (line.starts_with(docname_prefix)) {
		_document_name = line.substr(docname_prefix.length());
		return;
	}
	string titleabbr_prefix = ".. |titleAbbr| replace:: ";
	if (line.starts_with(titleabbr_prefix)) {
		_abbreviated_title = line.substr(titleabbr_prefix.length());
		return;
	}

	if (line == ".. header::") {
		output_header(output_stream);
		return;
	}
	if (line.starts_with("=") && line.find_first_not_of("=", 0) == string::npos) {
		if (!_contexts.empty() && (_contexts.top() == rst_context::TITLE)) {
			_contexts.pop(); // End of title.
			return;
		}

		// Title marker begins after a blank line.
		if (_previous_line.find_first_not_of(" ") == string::npos) {
			_contexts.push(rst_context::TITLE);
			return;
		}

		// Previous line is a section heading.
		while (_section_depth > 0) {
			output_stream << "</section>" << endl;
			_section_depth--;
		}
		output_stream << format("<section title=\"{}\">", _previous_line) << endl;
		_section_depth++;
		_previous_line.clear();
		return;
	}
	if (line.starts_with("-") && line.find_first_not_of("-", 0) == string::npos) {
		// Previous line is a L2 section heading.
		while (_section_depth > 1) {
			output_stream << "</section>" << endl;
			_section_depth--;
		}
		output_stream << format("<section title=\"{}\">", _previous_line) << endl;
		_section_depth++;
		_previous_line.clear();
		return;
	}
	if (line.starts_with("~") && line.find_first_not_of("~", 0) == string::npos) {
		// Previous line is a L3 section heading.
		while (_section_depth > 2) {
			output_stream << "</section>" << endl;
			_section_depth--;
		}
		output_stream << format("<section title=\"{}\">", _previous_line) << endl;
		_section_depth++;
		_previous_line.clear();
		return;
	}
	if (!_contexts.empty() && _contexts.top() == rst_context::TITLE) {
		output_stream << format("<title abbrev=\"{}\">{}</title>", _abbreviated_title, line) << endl;
		return;
	}

	output_previous_line(output_stream);
	_previous_line = line;
}

// Output the previous line.
void rst2rfcxml::output_previous_line(std::ostream& output_stream)
{
	if (_contexts.empty() && _previous_line.find_first_not_of(" ") != string::npos) {
		output_stream << "<t>";
		_contexts.push(rst_context::PARAGRAPH);
	}

	if (!_previous_line.empty()) {
		output_stream << _previous_line << endl;
	}

	if (_previous_line.find_first_not_of(" ") == string::npos) {
		// End any contexts that end at a blank line.
		while (!_contexts.empty()) {
			if (_contexts.top() == rst_context::PARAGRAPH) {
				output_stream << "</t>" << endl;
				_contexts.pop();
			} else if (_contexts.top() == rst_context::UNORDERED_LIST) {
				output_stream << "</ul>" << endl;
				_contexts.pop();
			} else {
				break;
			}
		}
	}
}

// Process all lines in an input stream.
void rst2rfcxml::process_input_stream(istream& input_stream, ostream& output_stream)
{
	string line;
	while (getline(input_stream, line)) {
		process_line(line, output_stream);
	}
	process_line({}, output_stream);
}

void rst2rfcxml::process_files(vector<string> input_filenames, ostream& output_stream)
{
	for (auto input_filename : input_filenames) {
		ifstream input_file(input_filename);
		process_input_stream(input_file, output_stream);
	}
	output_footer(output_stream);
}

int main(int argc, char** argv)
{
	CLI::App app{ "A reStructured Text to xmlrfc Version 3 converter" };
	string output_filename;
	app.add_option("-o", output_filename, "Output filename");
	vector<string> input_filenames;
	app.add_option("-i,input", input_filenames, "Input filenames")->mandatory(true);
	CLI11_PARSE(app, argc, argv);

	rst2rfcxml rst2rfcxml;
	if (output_filename.empty()) {
		rst2rfcxml.process_files(input_filenames, cout);
	} else {
		ofstream outfile(output_filename);
		rst2rfcxml.process_files(input_filenames, outfile);
	}
	return 0;
}
