// Copyright (c) Dave Thaler
// SPDX-License-Identifier: MIT

#include <fstream>
#include <sstream>
#include <string>
#include "..\external\CLI11.HPP"
#include "rst2rfcxml.h"

using namespace std;

void rst2rfcxml::output_header(ostream& output_stream) const
{
	output_stream << R"(<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
  <!-- generated by https://github.com/dthaler/rst2rfcxml version 0.1 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

)";

	output_stream << std::format("<rfc ipr=\"{}\" docName=\"{}\" category=\"{}\">", _ipr, _document_name, _category) << endl << endl;
	output_stream << "  <front>" << endl;
	output_stream << "  </front>" << endl << endl;
	output_stream << "  <middle>" << endl;
}

void rst2rfcxml::output_footer(ostream& output_stream) const
{
	output_stream << "  </middle>" << endl;
	output_stream << "  <back>" << endl;
	output_stream << "  </back>" << endl;
	output_stream << "</rfc>" << endl;
}

void rst2rfcxml::process_line(string line, ostream& output_stream)
{
	if (line == ".. contents::") {
		// Include table of contents.
		// This is already the default in rfc2xml.
		return;
	}
	if (line == ".. sectnum::") {
		// Number sections.
		// This is already the default in rfc2xml.
		return;
	}

	// Handle setting some field replacement values.
	string ipr_prefix = ".. |ipr| replace:: ";
	if (line.starts_with(ipr_prefix)) {
		_ipr = line.substr(ipr_prefix.length());
		return;
	}
	string category_prefix = ".. |category| replace:: ";
	if (line.starts_with(category_prefix)) {
		_category = line.substr(category_prefix.length());
		return;
	}
	string docname_prefix = ".. |docName| replace:: ";
	if (line.starts_with(docname_prefix)) {
		_document_name = line.substr(docname_prefix.length());
		return;
	}
	string titleabbr_prefix = ".. |titleAbbr| replace:: ";
	if (line.starts_with(titleabbr_prefix)) {
		_abbreviated_title = line.substr(titleabbr_prefix.length());
		return;
	}

	if (line == ".. header::") {
		output_header(output_stream);
		return;
	}
	if (line.starts_with("=") && line.find_first_not_of("=", 0) == -1) {
		if (_context == rst_context::TITLE) {
			_context = rst_context::NONE; // End of title.
			return;
		}

		// Title marker begins after a blank line.
		if (_previous_line.find_first_not_of(" ") == -1) {
			_context = rst_context::TITLE;
			return;
		}

		// Previous line is a section heading.
		while (_section_depth > 0) {
			output_stream << "</section>" << endl;
			_section_depth--;
		}
		output_stream << format("<section title=\"{}\">", _previous_line) << endl;
		_section_depth++;
		_previous_line.clear();
		return;
	}
	if (line.starts_with("-") && line.find_first_not_of("-", 0) == -1) {
		// Previous line is a L2 section heading.
		while (_section_depth > 1) {
			output_stream << "</section>" << endl;
			_section_depth--;
		}
		output_stream << format("<section title=\"{}\">", _previous_line) << endl;
		_section_depth++;
		_previous_line.clear();
		return;
	}
	if (line.starts_with("~") && line.find_first_not_of("~", 0) == -1) {
		// Previous line is a L3 section heading.
		while (_section_depth > 2) {
			output_stream << "</section>" << endl;
			_section_depth--;
		}
		output_stream << format("<section title=\"{}\">", _previous_line) << endl;
		_section_depth++;
		_previous_line.clear();
		return;
	}
	if (_context == rst_context::TITLE) {
		output_stream << format("<title abbrev=\"{}\">{}</title>", _abbreviated_title, line) << endl;
		return;
	}

	// By default, just output the previous line.
	output_stream << _previous_line << endl;
	_previous_line = line;
}

void rst2rfcxml::process_file(istream& input_stream, ostream& output_stream)
{
	string line;
	while (getline(input_stream, line)) {
		process_line(line, output_stream);
	}
	process_line({}, output_stream);
}

void rst2rfcxml::process_files(vector<string> input_filenames, ostream& output_stream)
{
	for (auto input_filename : input_filenames) {
		ifstream input_file(input_filename);
		process_file(input_file, output_stream);
	}
	output_footer(output_stream);
}

int main(int argc, char** argv)
{
	CLI::App app{ "A reStructured Text to xmlrfc Version 3 converter" };
	string output_filename;
	app.add_option("-o", output_filename, "Output filename");
	vector<string> input_filenames;
	app.add_option("-i,input", input_filenames, "Input filenames")->mandatory(true);
	CLI11_PARSE(app, argc, argv);

	rst2rfcxml rst2rfcxml;
	if (output_filename.empty()) {
		rst2rfcxml.process_files(input_filenames, cout);
	} else {
		ofstream outfile(output_filename);
		rst2rfcxml.process_files(input_filenames, outfile);
	}
	return 0;
}
