// Copyright (c) Dave Thaler
// SPDX-License-Identifier: MIT

#include <fstream>
#include <sstream>
#include <string>
#include "..\external\CLI11.HPP"
#include "rst2rfcxml.h"

using namespace std;

// Output XML header.
void rst2rfcxml::output_header(ostream& output_stream)
{
	output_stream << R"(<?xml version="1.0" encoding="UTF-8"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
  <!-- generated by https://github.com/dthaler/rst2rfcxml version 0.1 -->

<!DOCTYPE rfc [
]>

<?rfc rfcedstyle="yes"?>
<?rfc toc="yes"?>
<?rfc tocindent="yes"?>
<?rfc sortrefs="yes"?>
<?rfc symrefs="yes"?>
<?rfc strict="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc text-list-symbols="-o*+"?>
<?rfc docmapping="yes"?>

)";

	output_stream << std::format("<rfc ipr=\"{}\" docName=\"{}\" category=\"{}\">", _ipr, _document_name, _category) << endl << endl;
	output_stream << "  <front>" << endl;
	output_stream << "  </front>" << endl << endl;
	output_stream << "  <middle>" << endl;
}

void rst2rfcxml::pop_contexts(int level, ostream& output_stream)
{
	while (_contexts.size() > level) {
		switch (_contexts.top()) {
		case rst_context::TEXT:
			output_stream << "</t>" << endl;
			break;
		case rst_context::SECTION:
			output_stream << "</section>" << endl;
			break;
		case rst_context::UNORDERED_LIST:
			output_stream << "</ul>" << endl;
			break;

		default:
			break;
		}
		_contexts.pop();
	}
}

// Output XML footer.
void rst2rfcxml::output_footer(ostream& output_stream)
{
	pop_contexts(0, output_stream);
	output_stream << "  </middle>" << endl;
	output_stream << "  <back>" << endl;
	output_stream << "  </back>" << endl;
	output_stream << "</rfc>" << endl;
}

// Replace occurrences of ``foo`` with <tt>foo</tt>.
string rst2rfcxml::replace_constant_width_instances(string line) const
{
	size_t index;
	while ((index = line.find("``")) != string::npos) {
		size_t next_index = line.find("``", index + 2);
		if (next_index == string::npos) {
			break;
		}
		string before = line.substr(0, index);
		string middle = line.substr(index + 2, next_index - index - 2);
		string after = line.substr(next_index + 2);
		line = format("{}<tt>{}</tt>{}", before, middle, after);
	}
	return line;
}

// Handle escaping of & and <.
std::string rst2rfcxml::handle_escapes(std::string line) const
{
	size_t index;

	// Escape &.
	size_t start = 0;
	while ((index = line.find("&", start)) != string::npos) {
		line.replace(index, 1, "&amp;");
		start = index + 1;
	}

	// Escape <.
	while ((index = line.find("<")) != string::npos) {
		line.replace(index, 1, "&lt;");
	}

	// Escape >.
	while ((index = line.find(">")) != string::npos) {
		line.replace(index, 1, "&gt;");
	}
	return line;
}

// Process a single line of input.
void rst2rfcxml::process_line(string line, ostream& output_stream)
{
	line = handle_escapes(line);
	line = replace_constant_width_instances(line);

	if (line == ".. contents::") {
		// Include table of contents.
		// This is already the default in rfc2xml.
		return;
	}
	if (line == ".. sectnum::") {
		// Number sections.
		// This is already the default in rfc2xml.
		return;
	}

	// Handle setting some field replacement values.
	string ipr_prefix = ".. |ipr| replace:: ";
	if (line.starts_with(ipr_prefix)) {
		_ipr = line.substr(ipr_prefix.length());
		return;
	}
	string category_prefix = ".. |category| replace:: ";
	if (line.starts_with(category_prefix)) {
		_category = line.substr(category_prefix.length());
		return;
	}
	string docname_prefix = ".. |docName| replace:: ";
	if (line.starts_with(docname_prefix)) {
		_document_name = line.substr(docname_prefix.length());
		return;
	}
	string titleabbr_prefix = ".. |titleAbbr| replace:: ";
	if (line.starts_with(titleabbr_prefix)) {
		_abbreviated_title = line.substr(titleabbr_prefix.length());
		return;
	}

	if (line == ".. header::") {
		output_header(output_stream);
		return;
	}
	if (line.starts_with("=") && line.find_first_not_of("=", 0) == string::npos) {
		if (!_contexts.empty() && (_contexts.top() == rst_context::TITLE)) {
			_contexts.pop(); // End of title.
			return;
		}

		// Title marker begins after a blank line.
		if (_previous_line.find_first_not_of(" ") == string::npos) {
			_contexts.push(rst_context::TITLE);
			return;
		}

		// Previous line is a L1 section heading.
		pop_contexts(0, output_stream);
		output_stream << format("<section title=\"{}\">", _previous_line) << endl;
		_contexts.push(rst_context::SECTION);
		_previous_line.clear();
		return;
	}
	if (line.starts_with("-") && line.find_first_not_of("-", 0) == string::npos) {
		// Previous line is a L2 section heading.
		pop_contexts(1, output_stream);
		output_stream << format("<section title=\"{}\">", _previous_line) << endl;
		_contexts.push(rst_context::SECTION);
		_previous_line.clear();
		return;
	}
	if (line.starts_with("~") && line.find_first_not_of("~", 0) == string::npos) {
		// Previous line is a L3 section heading.
		pop_contexts(2, output_stream);
		output_stream << format("<section title=\"{}\">", _previous_line) << endl;
		_contexts.push(rst_context::SECTION);
		_previous_line.clear();
		return;
	}
	if (!_contexts.empty() && _contexts.top() == rst_context::TITLE) {
		output_stream << format("<title abbrev=\"{}\">{}</title>", _abbreviated_title, line) << endl;
		return;
	}

	output_previous_line(output_stream);
	_previous_line = line;
}

// Output the previous line.
void rst2rfcxml::output_previous_line(std::ostream& output_stream)
{
	if (_previous_line.starts_with("* ")) {
		if (_contexts.empty() || _contexts.top() != rst_context::UNORDERED_LIST) {
			output_stream << "<ul>" << endl;
			_contexts.push(rst_context::UNORDERED_LIST);
		}
		output_stream << format("<li>{}</li>", _previous_line.substr(2)) << endl;
	} else if (_previous_line.find_first_not_of(" ") != string::npos) {
		if (_contexts.empty() || _contexts.top() != rst_context::TEXT) {
			output_stream << "<t>" << endl;
			_contexts.push(rst_context::TEXT);
		}
		output_stream << _previous_line << endl;
	}

	if (_previous_line.find_first_not_of(" ") == string::npos) {
		// End any contexts that end at a blank line.
		while (!_contexts.empty()) {
			if (_contexts.top() == rst_context::TEXT) {
				output_stream << "</t>" << endl;
				_contexts.pop();
			} else if (_contexts.top() == rst_context::UNORDERED_LIST) {
				output_stream << "</ul>" << endl;
				_contexts.pop();
			} else {
				break;
			}
		}
	}
}

// Process all lines in an input stream.
void rst2rfcxml::process_input_stream(istream& input_stream, ostream& output_stream)
{
	string line;
	while (getline(input_stream, line)) {
		process_line(line, output_stream);
	}
	process_line({}, output_stream);
}

// Process multiple input files that contribute to an output file.
void rst2rfcxml::process_files(vector<string> input_filenames, ostream& output_stream)
{
	for (auto input_filename : input_filenames) {
		ifstream input_file(input_filename);
		process_input_stream(input_file, output_stream);
	}
	output_footer(output_stream);
}

int main(int argc, char** argv)
{
	CLI::App app{ "A reStructured Text to xmlrfc Version 3 converter" };
	string output_filename;
	app.add_option("-o", output_filename, "Output filename");
	vector<string> input_filenames;
	app.add_option("-i,input", input_filenames, "Input filenames")->mandatory(true);
	CLI11_PARSE(app, argc, argv);

	rst2rfcxml rst2rfcxml;
	if (output_filename.empty()) {
		rst2rfcxml.process_files(input_filenames, cout);
	} else {
		ofstream outfile(output_filename);
		rst2rfcxml.process_files(input_filenames, outfile);
	}
	return 0;
}
